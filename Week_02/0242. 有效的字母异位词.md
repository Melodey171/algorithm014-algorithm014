#### 242. 有效的字母异位词

**Difficulty:** Easy

#### 方法一：排序

如果两个字符串互为字母异位词，则必须满足以下两个条件：

1. 两个字符串的长度相等；

2. 存在一种排列方式，使得两个字符串都可按照该方式排列。

因此，将两个字符串分别转化成数组，再对两个数组进行排序，判断排序之后的两个数组是否相等，即可判断两个字符串是否互为字母异位词。此外，如果 s 和 t的长度不同，t不可能是 s的变位词，我们可以提前返回。

```
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
    	if len(s) != len(t):
            return False
        return True if sorted(s)==sorted(t) else False
```

**复杂度分析**

- 时间复杂度：O(n log n)，其中n是字符串的长度。排序的时间复杂度是O(n log n)，判断两个数组是否相等的时间复杂度是O(n)。

- 空间复杂度：O(n)，其中n是字符串的长度。将字符串转化成数组，额外创建了两个数组。

#### 方法二：哈希表

如果两个字符串互为字母异位词，则必须满足以下两个条件：

1. 两个字符串的长度相等；

2. 同一个字母在两个字符串中出现的次数相等。

基于上述条件，判断两个字符串是否互为字母异位词可以分成两步，第一步是判断长度是否相等，如果不相等则直接返回 `false`，如果相等再进入第二步，统计每个字母在两个字符串中出现的次数。所以哈希表就是一种不错的选择。

```
class Solution(object):
    def isAnagram(self, s, t):
        dic = {}
        for i in s:
            if i not in dic:
                dic[i] = 1
            else:
                dic[i] += 1
        
        for j in t:
            if j not in dic:
                return False
            else:
                dic[j] -= 1
        
        for val in dic.values():
            if val != 0:
                return False
        
        return True
```

**复杂度分析**

- 时间复杂度：O(n)，其中n是字符串的长度。对两个字符串各遍历一次，时间复杂度是O(n)，最后遍历哈希表的时间复杂度也是O(n)。
- 空间复杂度：O(n)，其中n是字符串的长度。哈希表需要存储每个出现过的字符及其出现次数，不同字符的数量不会超过两个字符串的长度之和。

**注**

如果字符串中只包含小写字母的情况下，可以将哈希表简化成数组，这样时间复杂为O(n)，空间复杂度就变成了O(1)了。

