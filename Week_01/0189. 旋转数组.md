#### 189. 旋转数组

**Difficulty:** Easy

#### 预处理

这道题的解法很多，可以使用暴力法，最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。
时O(n∗k) ，空O(1)；可以使用使用额外的数组，用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 iii 的我们把它放到 (i+k)%数组长度(i+k)\%数组长度(i+k)%数组长度 的位置。然后把新的数组拷贝到原数组中，时间复杂度和空间复杂度都是O(n)；还可以用环状替换的方法，时间复杂度：O(n)，空间复杂度：O(1)

#### 方法一：反转数组

数组向右旋转k个位置后，原来在数组最后的k个元素变成在数组最前的k个元素。

反转整个数组之后，原来在数组最后的k个元素也变成在数组最前的k个元素，但是元素顺序被反转。此时如果再分别反转数组最前的k个元素和数组最后的n-k个元素，即可得到旋转后的数组。

考虑以下数组：
```
a[0], a[1], ..., a[n-k-1], a[n-k], ..., a[n-1]
```
反转整个数组：
```
a[n-1], ..., a[n-k], a[n-k-1], ..., a[1], a[0]
```
反转前k个元素：
```
a[n-k], a[n-k+1], ..., a[n-1], a[n-k-1], ..., a[1], a[0]
```
反转后n-k个元素：
```
a[n-k], a[n-k+1], ..., a[n-1], a[0], ..., a[n-k-1]
```
此时得到的数组即为旋转k个位置之后的数组。

```
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        #三次翻转 时O(n) 空O(1)
        n=len(nums)
        k=k%n
        def swap(l,r):
            while(l<r):
                nums[l],nums[r]=nums[r],nums[l]
                l=l+1
                r=r-1
        swap(0,n-k-1)
        swap(n-k,n-1)
        swap(0,n-1)
```

**复杂度分析**

- 时间复杂度：O(n)，其中n是数组的长度。一共有三次反转操作，第一次反转整个数组，被反转的元素个数是n，第二次和第三次分别反转两个子数组，被反转的元素个数一共是n。

- 空间复杂度：O(1)。