# 第三周学习笔记

算法题的作业每道题为一个md文件，每道题包含一种或多种解法，每种解法都包含解题思路、代码实现和复杂度分析。

## 第7课 泛型递归、树的递归

### 一、递归

#### 1. 递归的本质

递归的实质是循环，是通过函数体进行的循环。

递归是分治和动态规划的基础，而贪心是动态规划的一种特殊情况（局部最优不一定是全局最优）。

递归和迭代本质是一样的，迭代只是我们自己模拟了递归的调用栈而已，因此迭代一般会用到栈这样的数据结构。

分治是一种算法思想，递归是一种技术手段。

#### 2. 递归的组成部分

递归包含四个部分：

1. 递归终止条件，满足该条件直接结束递归；

2. 处理当前层逻辑；

3. 调用递归进入下一层；

4. 清理当前层（根据实际情况决定是否需要）。

#### 3. 递归的python代码模板

```
​```
def recursion(level, param1, param2,...):
	# recursion terminator
	# 终止条件
	if level > MAX_LEVEL:
	process_result
	
	# process logic in current level
	# 处理当前层逻辑
	process(level, data...)
	
	# drill down
	# 下探到下一层
	self.recursion(level+1, p1,...)
	
	#reverse the current level status if needed
	# 清理当前层
	
​```
```

#### 4. 思维要点

1. 避免人肉进行递归；

2. 找到最近最简方法，将其拆解成可重复解决的子问题，（找重复性子问题）；

3. 数学归纳法思维。

#### 5. 实战题目

[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)  

### 二、树的递归

树的题目经常使用递归，因为树具有重复性。

以二叉树为例，给定树的根节点，通常可以对根节点的左右子节点进行递归操作。

## 第8课 分治、回溯

### 一、分治

#### 1. 定义

分治，将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立，且与原问题性质相同。求出子问题的解后进行合并，就可以得到原问题的解。

有些问题递归需要将原问题分解成多个子问题，而有的只需要分解成一个子问题，因此有的人将前面那种情况称作分治，将后面那种情况称作递归。

递归跟迭代是一一对应的，因此分治有两种解法: 递归和迭代。

分治是一种典型的递归结构。

分治是一种算法思想，递归是一种技术手段。

#### 2. 本质

分治的思想就是递归，实质是找重复性和分解成子问题，然后组合子问题的结果。

#### 3. 解题步骤

1. 分解；2. 求解；3. 合并。

分治可以高效解决问题，因为没有中间结果（没有所谓的重复计算）。

### 二、回溯

#### 1. 定义

回溯法又称为试探法，当探索到某一步时，发现原先选择达不到目的，就退回一步重新选择（走不通就退回重走）。

回溯是类似于DFS的算法，可以理解为一个N叉树的遍历，比如斐波那契数列可以理解为一个二叉树，二零钱兑换可以理解为一个N叉树。

#### 2. 本质

回溯的实质是递归，在每一层尝试答案，直到找到答案，或者遍历所有的可能之后发现不存在答案。

#### 3. 优缺点

- 优点是容易想到
- 缺点是只能面对小数据集，使用面有限。

## 一周总结

第3周的课程主要讲了递归、分治和回溯。分治和回溯的实质都是递归，因此第3周的课程内容都是围绕递归进行的。

递归的含义是程序调用自身的技巧。递归在算法中被广泛应用，通过递归，可以把一个规模大的问题分解成与原始问题相似的规模小的问题进行求解，从而使用有限的代码量解决规模大的问题。

递归适用的场景是具有相似子问题的场景，通过解决子问题从而解决原始问题。递归调用不能无限进行，因此必须存在基准情形，在基准情形下可以直接得到结果。

递归经常被用于树相关的算法，因为树本身就具有重复性，子树与原始的树结构相似，且子树的规模更小，因此非常适合用递归。

分治是典型的递归应用。分治法将原始问题分解成子问题，通过对每个子问题递归得到答案，然后将答案合并，得到原始问题的答案。

回溯是通过递归的方式搜索解空间，直到找到解，或者遍历整个空间之后发现不存在解。最坏情况下，回溯的时间复杂度为指数级。

递归的缺点在于运行效率低于常用的算法如循环，而且递归调用需要额外使用栈空间，如果递归次数过多，则会导致时间复杂度过高以及栈溢出。对于递归的优化通常有两种方式，一是记忆化递归，即一个子问题如果已经出现过，则将其结果存储，在下次遇到同一个子问题的时候就不需要再次计算，而是可以直接得到存储的结果，二是将递归实现改成迭代实现。